---
layout: default
---

# 不直接用NSLog

摘要: 公司中不直接使用NSLog,而是利用宏定义自己的打印函数,将该打印函数写在项目的.pch文件中.调试的时候往往用到好多打印,但发布的时候确不需要.(以下是在公司中的一些处理方法)

正文

一,固定写法:

### define  MYLog(...)  NSLog(`__VA_ARGS__`)

二,注意:

        1,MYLog括号中的...是固定写法,表示可以接受任意多个参数.

        2,NSLog括号中的`__VA_ARGS__`  也是固定写法,前后用了两个下划线

三,使用方式:

        项目中Supporting files文件夹下有个 "工程名-Prefix.pch"文件,你可以在该文件下声明

### define  MYLog(...)  NSLog(`__VA_ARGS__`)

        这样之后工程中的任何一个文件中都可以使用改自定的打印函数(也就是说可以在该.pch中放一些全局的东西)

四,好处:

        这样使用的好处就是,项目调试期间,我们可能会用到好多MYLog()函数打印.

        如果不需要时,只需将.pch中该宏修改为:(这样就相当于MYLog()代表的是注释了)

### define  MYLog(...)  //NSLog(`__VA_ARGS__`)

五,修改:(这样做还不够智能,每次调试的时候需要用到打印,发布的时候不需要打印还要手动修改一下)  

        其实系统提供了一个宏  DEBUG 表示在调试状态下

        因为上述代码可以优化为:    (下述代码是公司常用代码)

```objective-c
#ifdef DEBUG  //调试阶段
#define MYLog(...)  NSLog(__VA_ARGS__)
#else //发布阶段
#define MYLog(...)
#endif
```

使用NSLog的一个风险是：它的运行会占用时间和设备资源。当我们用Simulator时，NSLog的资源占用并不引人注意，风险也不会显示出来。但是如果你写的是一个即时战略游戏，而你在每一个action中都加入了NSLog——那么NSLog将成为一个魔鬼。灾难的具体表现常常是：你在Simulator中运行游戏畅通无阻，但到了真机上，会发现很“卡”，不论是拖动一个单位还是缩放一个场景，FPS也降到了各位数。

简单而粗暴的解决方案是：在一个游戏release前，将所有的NSLog注释掉。简单有效，但副作用是：下次你要调试时，又得将NSLog一个个取消注释。

解决方案：你以release模式编译的程序不会用NSLog输出，而你以debug模式编译的程序将执行NSLog的全部功能。

```objective-c
#ifndef OPTIMIZE

#define NSLog(…) NSLog(__VA_ARGS__)

#else

#define NSLog(…) {}

#endif
```

这个代码的魔术在于：release模式通常会定义 __OPTIMIZE__，当然debug模式不会。将这段代码放在你的头文件当中，你就可以放心的使用NSLog了！

 

上面的宏是使用qDebug输出调试信息，在非Qt的程序中也可以改为printf，守护进程则可以改为syslog等等... 其中，决窍其实就是这几个宏 ##`__VA_ARGS__`, `__FILE__`, `__LINE__` 和`__FUNCTION__`,下面介绍一下这几个宏:

补充：

　　1) `__VA_ARGS__` 是一个可变参数的宏，很少人知道这个宏，这个可变参数的宏是新的C99规范中新增的，目前似乎只有gcc支持（VC6.0的编译器不支持）。宏前面加上##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的","去掉的作用,否则会编译出错, 你可以试试。

　　2) `__FILE__` 宏在预编译时会替换成当前的源文件名

　　3) `__LINE__`宏在预编译时会替换成当前的行号

　　4) `__FUNCTION__`宏在预编译时会替换成当前的函数名称



[BackHome](http://ablexie.github.io/)



